!function(t){var c={};function n(I){if(c[I])return c[I].exports;var g=c[I]={i:I,l:!1,exports:{}};return t[I].call(g.exports,g,g.exports,n),g.l=!0,g.exports}n.m=t,n.c=c,n.d=function(t,c,I){n.o(t,c)||Object.defineProperty(t,c,{enumerable:!0,get:I})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,c){if(1&c&&(t=n(t)),8&c)return t;if(4&c&&"object"==typeof t&&t&&t.__esModule)return t;var I=Object.create(null);if(n.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:t}),2&c&&"string"!=typeof t)for(var g in t)n.d(I,g,function(c){return t[c]}.bind(null,g));return I},n.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(c,"a",c),c},n.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/weatherInformation.js\nclass WeatherInformation {\r\n    constructor(weatherInfo) {\r\n      this.location = weatherInfo.name,\r\n      this.country = weatherInfo.sys.country\r\n      this.date = new Date(),\r\n      this.temp = weatherInfo.main.temp,\r\n      this.iconName = weatherInfo.weather[0].main,\r\n      this.pressure = weatherInfo.main.pressure,\r\n      this.humidity = weatherInfo.main.humidity,\r\n      this.windSpped = weatherInfo.wind.speed\r\n    }\r\n  \r\n    setLocation() {\r\n      const locationID = document.getElementsByClassName(\"headText__location--js\")[0];\r\n      locationID.innerHTML = `in ${this.location}, ${this.country}`;\r\n    }\r\n    setDate() {\r\n      const dateID = document.getElementsByClassName(\"headText__date--js\")[0];\r\n      dateID.innerHTML = `Today ${this.date.getDate()}th, ${this.date.toLocaleString('en-EN', {month: 'long'})}`\r\n    }\r\n    \r\n    setTemp() {\r\n      const tempID = document.getElementsByClassName(\"headText--degrees-js\")[0];\r\n      tempID.innerHTML = `${this.temp.toFixed(1)} Â°C`;\r\n    }\r\n  \r\n    setPressure() {\r\n      const pressureID = document.getElementsByClassName(\"weatherToday__pressure--js\")[0];\r\n      pressureID.innerHTML = `${this.pressure} hPa`;\r\n    }\r\n  \r\n    setHumidity() {\r\n      const humidityID = document.getElementsByClassName(\"weatherToday__humidity--js\")[0];\r\n      humidityID.innerHTML = `${this.humidity} %`;\r\n    }\r\n  \r\n    setWindSpeed() {\r\n      const windSpeedID = document.getElementsByClassName(\"weatherToday__windSpeed--js\")[0];\r\n      windSpeedID.innerHTML = `${this.windSpped} m/s`;\r\n    }\r\n  \r\n    setWeatherInformation() {\r\n      this.setLocation();\r\n      this.setDate();\r\n      this.setTemp();\r\n      this.setPressure();\r\n      this.setHumidity();\r\n      this.setWindSpeed();\r\n    }\r\n  \r\n    weatherIcon(weather) {\r\n      let currentDate = new Date();\r\n      currentDate = currentDate.getHours();\r\n      switch(weather) {\r\n        case 'thunderstorm':\r\n          return 'storm.svg';\r\n          break;\r\n        case 'Drizzle':\r\n          return 'Drizzle.svg';\r\n          break;\r\n        case 'Rain':\r\n          return 'Rain.svg';\r\n          break;\r\n        case 'Snow':\r\n          return 'Snowflake.svg';\r\n          break;\r\n        case 'Atmosphere':\r\n          return 'fog.svg';\r\n          break;\r\n        case 'Clear':\r\n          if(currentDate <= 20) {\r\n            return 'sun.svg';\r\n            break;\r\n          }\r\n          else {\r\n            return 'moon.svg';\r\n            break;\r\n          }\r\n        case 'Clouds':\r\n          return 'Clouds.svg'\r\n          break;\r\n      }\r\n    }\r\n  \r\n    setImage() {\r\n      const imageID = document.getElementsByClassName(\"weatherImage--js\")[0];\r\n      const weatherName = this.weatherIcon(this.iconName);\r\n      imageID.src = `assets/img/${weatherName}`;\r\n    }\r\n    roundTemp(temp) {\r\n      return Math.round((temp * 100)/100);\r\n    }\r\n  }\n// CONCATENATED MODULE: ./src/js/chartClass.js\nclass Chart {\r\n    constructor(weatherData, axisXposition) {\r\n      this.axisXposition = axisXposition;\r\n      this.weatherByHour = weatherData;\r\n      this.condition = false;\r\n      this.state = {};\r\n      this.tooltip = document.getElementsByClassName(\"chartTemp__tooltip\")[0];\r\n      this.canvas = document.getElementById(\"chartTemp__canvas\");\r\n      this.ctx = this.canvas.getContext(\"2d\");\r\n    }\r\n  \r\n    canvasDimensions() {\r\n      this.canvas.width = 660;\r\n      this.canvas.height = 309;\r\n    }\r\n  \r\n    blocks(count) {\r\n      return count * 40;\r\n    }\r\n  \r\n    drawGrid() {\r\n      let gridX = 40;\r\n      let gridY = 40;\r\n      const cellSize = 40;\r\n      this.ctx.beginPath();\r\n      this.ctx.strokeStyle = \"lightgrey\";\r\n    \r\n      while (gridX <= this.canvas.width - 20) {\r\n        this.ctx.moveTo(gridX, 20);\r\n        this.ctx.lineTo(gridX, this.canvas.height - 20);\r\n        gridX += cellSize;\r\n      }\r\n      while (gridY <= this.canvas.height - 20) {\r\n        this.ctx.moveTo(20, gridY);\r\n        this.ctx.lineTo(this.canvas.width - 10, gridY);\r\n        gridY += cellSize;\r\n      }\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    async drawAxis(hours) {\r\n      this.ctx.beginPath();\r\n      this.ctx.strokeStyle = \"black\";\r\n      this.ctx.moveTo(this.blocks(1), this.blocks(1 / 2));\r\n      this.ctx.lineTo(this.blocks(1), this.blocks(7));\r\n      this.ctx.lineTo(this.blocks(16), this.blocks(7));\r\n    \r\n      this.ctx.moveTo(this.blocks(1), this.blocks(7));\r\n      let text = 0;\r\n      let textY = this.blocks(7);\r\n      for (let i = 1; i <= 7; i++) {\r\n        this.ctx.strokeText(text, this.blocks(1 / 2), textY);\r\n        textY -= 40;\r\n        text += 5;\r\n      }\r\n    \r\n      this.ctx.moveTo(this.blocks(2), this.blocks(7));\r\n      let textX = this.blocks(1.9);\r\n    \r\n      for (let i = 0; i <= 15; i++) {\r\n        this.ctx.strokeText(hours[i], textX, this.blocks(7.5));\r\n        textX += 40;\r\n      }\r\n      this.ctx.stroke();\r\n    }\r\n    timestampToTime(stamp) {\r\n      let date = new Date(stamp * 1000);\r\n      return date.getHours();\r\n    }\r\n    \r\n    mapAndFilter(tempArray) {\r\n      tempArray = tempArray.map((el) => this.timestampToTime(el));\r\n      tempArray = tempArray.filter((el) => el % 2 == 0);\r\n      return tempArray;\r\n    }\r\n    \r\n    temperatureToChartCoords(temp){\r\n      let temperature = temp.map((el) => el / 5);\r\n      temperature = temperature.slice(0,15);\r\n      return temperature;\r\n    }\r\n    \r\n    getHoursCoords() {\r\n      let hourOfTemp = [...Array(17).keys()]\r\n      hourOfTemp = hourOfTemp.slice(2, 17);\r\n    \r\n      return hourOfTemp;\r\n    }\r\n    \r\n    drawChart(temperature) {\r\n      const tempHours = this.getHoursCoords();\r\n      let i = 1;\r\n      const context = this.ctx\r\n      const block = this.blocks.bind(this);\r\n      const axisXposition = this.axisXposition;\r\n      function animation() {\r\n        if (i <= temperature.length) {\r\n          window.requestAnimationFrame(animation);\r\n        }\r\n        context.strokeStyle = \"#FFE74A\";\r\n        context.lineWidth = 3;\r\n        context.beginPath();\r\n        context.moveTo(block(tempHours[i-1]), axisXposition - block(temperature[i-1]));\r\n        context.arc(block(tempHours[i-1]), axisXposition - block(temperature[i-1]), 3, 0, Math.PI * 2, true);\r\n        context.lineTo(block(tempHours[i]), axisXposition - block(temperature[i]));\r\n        context.stroke();\r\n        i++;\r\n      }\r\n      animation();\r\n    }\r\n    \r\n    async waitForGrid(ms) {\r\n      return new Promise(r => setTimeout(r, ms));\r\n    }\r\n    \r\n    getMousePosition(evt) {\r\n      let rect = this.canvas.getBoundingClientRect();\r\n      return {\r\n        x: evt.clientX - rect.left,\r\n        y: evt.clientY - rect.top\r\n      };\r\n    }\r\n    \r\n    filterTemperature(temperature) {\r\n      const temp = temperature\r\n        .map((obj) => obj.temp)\r\n        .filter((el, index) => index % 2 == 0);\r\n    \r\n      return temp;\r\n    }\r\n    \r\n    temperatureToPixel(temp){\r\n      temp = temp.map(el => this.axisXposition - this.blocks(el));\r\n      return temp;\r\n    }\r\n    \r\n    hoursToPixel(hours) {\r\n      const hourrs = hours.map(el => this.blocks(el));\r\n      return hourrs;\r\n    }\r\n    \r\n    createTempObj(hour, temp, hourOfTemp, tempInHour){\r\n      const tempPointCoords = [];\r\n      for (let i = 0; i < temp.length; i++){\r\n        tempPointCoords.push({\r\n          x: hour[i],\r\n          y: temp[i],\r\n          xmin: hour[i] - 3,\r\n          xmax: hour[i] + 3,\r\n          ymin: temp[i] - 3,\r\n          ymax: temp[i] + 3,\r\n          hourTemp: {\r\n            hour: hourOfTemp[i],\r\n            temp: tempInHour[i]\r\n          },\r\n    \r\n        })\r\n      }\r\n      return tempPointCoords;\r\n    }\r\n    \r\n    drawPoint(coords = {}, radius, color = 'white') {\r\n      const mouseCoordinate = coords;\r\n      this.ctx.strokeStyle = color;\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(mouseCoordinate.x, mouseCoordinate.y);\r\n      this.ctx.arc(mouseCoordinate.x, mouseCoordinate.y, radius, 0, Math.PI * 2, true);\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.fill();\r\n      this.ctx.stroke();\r\n    }\r\n    \r\n  \r\n    addPopUp(tempPoint) {\r\n      this.canvas.addEventListener('mousemove', (e) => {\r\n        const mouseCoords = this.getMousePosition(e);\r\n        let boools = tempPoint.filter(el => {\r\n          const a = el.xmin <= mouseCoords.x;\r\n          const b = mouseCoords.x <= el.xmax;\r\n          const c = el.ymin <= mouseCoords.y;\r\n          const d = mouseCoords.y <= el.ymax;\r\n          return (a && b && c && d)})\r\n        \r\n        if(boools.length) {\r\n          this.drawPoint(boools[0], 1);\r\n          this.state = {...boools[0]};\r\n          this.condition = true;\r\n          if (this.canvas.width - (this.state.x + 5) <= 80){\r\n            this.tooltip.style.left = `${this.state.x - 85}px`\r\n            this.tooltip.style.top = `${this.state.y - 35}px`;\r\n            \r\n          }\r\n          else {\r\n            this.tooltip.style.left = `${this.state.x + 5}px`;\r\n            this.tooltip.style.top = `${this.state.y - 35}px`;\r\n          }\r\n          this.tooltip.style.display = 'flex';\r\n          this.tooltip.innerHTML = `Time: ${this.state.hourTemp.hour}:00, Temp: ${this.state.hourTemp.temp}Â°C`;\r\n        } \r\n        else if(!boools.length) {\r\n          this.drawPoint(this.state, 3, \"#FFE74A\");\r\n          this.condition = false;\r\n          this.state = {};\r\n          this.tooltip.style.display = 'none';\r\n        } \r\n      })\r\n    }\r\n    \r\n    async chart() {\r\n      const hourOfWeather = this.mapAndFilter(this.weatherByHour.map((obj) => obj.dt));\r\n      let temperature = this.filterTemperature(this.weatherByHour);\r\n      const temperatureCoords = this.temperatureToChartCoords(temperature);\r\n      \r\n      const tempPixels = this.temperatureToPixel(temperatureCoords, this.axisXposition);\r\n      const hoursPixels = this.hoursToPixel(this.getHoursCoords());\r\n      \r\n      const tempPoints = this.createTempObj(hoursPixels, tempPixels, hourOfWeather, temperature);\r\n    \r\n      this.canvasDimensions();\r\n      this.drawGrid();\r\n      this.drawAxis(hourOfWeather);\r\n      await this.waitForGrid(500);\r\n      this.drawChart(temperatureCoords)\r\n      this.addPopUp(tempPoints);\r\n    }\r\n  \r\n  }\n// CONCATENATED MODULE: ./src/js/weekForecastClass.js\nclass WeekForecast {\r\n  constructor(weekForecastData) {\r\n    this.weekData = weekForecastData;\r\n    this.weatherForecastContainer = document.getElementsByClassName(\"weatherForecast--js\");\r\n    this.weatherForecastContainer = this.weatherForecastContainer[0];\r\n  }\r\n\r\n  sliceWeekDataArray(){\r\n    this.weekData = this.weekData.slice(1,8);\r\n    console.log(this.weekData)\r\n  }\r\n  getTimestampToTime(timestamp) {\r\n    const time = new Date(timestamp * 1000);\r\n    return time.getDay();\r\n  }\r\n  getNameOfWeek(number) {\r\n    switch (number) {\r\n      case 0:\r\n        return \"Sun\";\r\n        break;\r\n      case 1:\r\n        return \"Mon\";\r\n        break;\r\n      case 2:\r\n        return \"Tue\";\r\n        break;\r\n      case 3:\r\n        return \"Wed\";\r\n        break;\r\n      case 4:\r\n        return \"Thur\";\r\n        break;\r\n      case 5: \r\n        return \"Fri\";\r\n        break;\r\n      case 6:\r\n        return \"Sat\";\r\n        break\r\n    }\r\n  }\r\n  getWeatherParameters(){\r\n    this.weekData = this.weekData.map(el => {\r\n      return {\r\n        day: this.getNameOfWeek(this.getTimestampToTime(el.dt)), \r\n        temp: el.temp.day,\r\n        weather: el.weather[0].main\r\n      }\r\n    });\r\n    console.log(this.weekData)\r\n  }\r\n\r\n  putWeatherIntoSection(){\r\n    this.weatherForecastContainer.innerHTML = '';\r\n    this.weekData.forEach(el => {\r\n      this.weatherForecastContainer.innerHTML += `<div class=\"weatherForecast__day weatherForecast__day--js\"><img class=\"weatherForecast__dayElement\" src='/assets/img/weathericons/${this.weatherIcon(el.weather)}' alt=''></img><div class=\"weatherForecast__dayElement\"><p>${el.day}<br>${el.temp}</p></div></div>`\r\n    })\r\n  }\r\n\r\n  addWeatherForecast() {\r\n    this.sliceWeekDataArray();\r\n    this.getWeatherParameters();\r\n    this.putWeatherIntoSection();\r\n  }\r\n\r\n  weatherIcon(weather) {\r\n    let currentDate = new Date();\r\n    currentDate = currentDate.getHours();\r\n    switch(weather) {\r\n      case 'thunderstorm':\r\n        return 'storm.svg';\r\n        break;\r\n      case 'Drizzle':\r\n        return 'Drizzle.svg';\r\n        break;\r\n      case 'Rain':\r\n        return 'Rain.svg';\r\n        break;\r\n      case 'Snow':\r\n        return 'Snowflake.svg';\r\n        break;\r\n      case 'Atmosphere':\r\n        return 'fog.svg';\r\n        break;\r\n      case 'Clear':\r\n        if(currentDate <= 20) {\r\n          return 'sun.svg';\r\n          break;\r\n        }\r\n        else {\r\n          return 'moon.svg';\r\n          break;\r\n        }\r\n      case 'Clouds':\r\n        return 'Clouds.svg'\r\n        break;\r\n    }\r\n  }\r\n\r\n}\n// CONCATENATED MODULE: ./src/js/main.js\n\r\n\r\n\r\n\r\n// service worker registration - remove if you're not going to use it\r\n\r\nif (\"serviceWorker\" in navigator) {\r\n  window.addEventListener(\"load\", function () {\r\n    navigator.serviceWorker.register(\"serviceworker.js\").then(\r\n      function (registration) {\r\n        // Registration was successful\r\n        console.log(\r\n          \"ServiceWorker registration successful with scope: \",\r\n          registration.scope\r\n        );\r\n      },\r\n      function (err) {\r\n        // registration failed :(\r\n        console.log(\"ServiceWorker registration failed: \", err);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n// place your code below\r\nconst apiKey = \"53c5e97675c8d3d8da07e56aec5a3a22\";\r\nconst axisXposition = 280; // X axis is on 280px Canvas Height;\r\n\r\n(function () {\r\n  var lastTime = 0;\r\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n      window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n      window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n  }\r\n\r\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\r\n      var currTime = new Date().getTime();\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n      var id = window.setTimeout(function () {\r\n          callback(currTime + timeToCall);\r\n      },\r\n      timeToCall);\r\n      lastTime = currTime + timeToCall;\r\n      return id;\r\n  };\r\n\r\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\r\n      clearTimeout(id);\r\n  };\r\n}());\r\n\r\n\r\n\r\nfunction success(loc) {\r\n  const { coords } = loc;\r\n}\r\n\r\nfunction error(err) {\r\n  console.warn(`ERROR(${err.code}): ${err.message}`);\r\n}\r\n\r\nconst options = {\r\n  enableHighAccuracy: true,\r\n  timeout: 5000,\r\n  maximumAge: 0,\r\n};\r\n\r\nfunction consolValue(val) {\r\n  return val;\r\n}\r\n\r\nfunction main_location() {\r\n  return new Promise((resolve, reject) =>\r\n    navigator.geolocation.getCurrentPosition(resolve, error)\r\n  );\r\n}\r\n\r\nasync function getLocation(location) {\r\n  let position = location;\r\n  let weatherByPosition;\r\n  let weatherByHour;\r\n  let nextSevenDays;\r\n  if (typeof position === 'object') {\r\n    \r\n    position = await position.coords;\r\n    const { latitude, longitude } = position;\r\n  \r\n    weatherByPosition = await fetch(\r\n      `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric&lang=pl`\r\n    );\r\n    weatherByPosition = await weatherByPosition.json();\r\n    \r\n    weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n    exclude=hourly&appid=${apiKey}&units=metric`);\r\n    weatherByHour = await weatherByHour.json();\r\n    weatherByHour = weatherByHour.hourly;\r\n    \r\n    nextSevenDays = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n    exclude=daily&appid=${apiKey}&units=metric`)\r\n    nextSevenDays = await nextSevenDays.json();\r\n    nextSevenDays = nextSevenDays.daily;\r\n  }\r\n  else {\r\n    weatherByPosition = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${position}&appid=${apiKey}&units=metric`)\r\n    weatherByPosition = await weatherByPosition.json();\r\n    \r\n    const coords = weatherByPosition.coord;\r\n    console.log(coords)\r\n    weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${coords.lat}&lon=${coords.lon}&\r\n    exclude=hourly&appid=${apiKey}&units=metric`);\r\n    weatherByHour = await weatherByHour.json();\r\n    \r\n    weatherByHour = weatherByHour.hourly;\r\n\r\n    nextSevenDays = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${coords.lat}&lon=${coords.lon}&\r\n    exclude=daily&appid=${apiKey}&units=metric`)\r\n    nextSevenDays = await nextSevenDays.json();\r\n    nextSevenDays = nextSevenDays.daily;\r\n  }\r\n  \r\n\r\n\r\n  const weatherData = new WeatherInformation(weatherByPosition);\r\n  weatherData.setWeatherInformation();\r\n  const chart = new Chart(weatherByHour, axisXposition);\r\n  chart.chart();\r\n  const forecastForWeek = new WeekForecast(nextSevenDays);\r\n  forecastForWeek.addWeatherForecast();\r\n  \r\n}\r\n\r\nconst localization = document.getElementsByClassName('header__geolocalization--buttonJS')[0];\r\nconst searchButton = document.getElementsByClassName('header__search--buttonJS')[0];\r\nconst inputField = document.getElementsByClassName('header__search--inputJS')[0];\r\n\r\n\r\nlocalization.addEventListener('click', async () => {\r\n  const locations = await main_location();\r\n  getLocation(locations);\r\n})\r\n\r\nsearchButton.addEventListener('click', async () => {\r\n  if (!inputField.value) {\r\n    alert(\"please type your city name\");\r\n  }\r\n  else if (inputField.value) {\r\n    try {\r\n      await getLocation(inputField.value);\r\n    }\r\n    catch(error) {\r\n      alert('Please type corret city name')\r\n    }\r\n  }\r\n})//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvd2VhdGhlckluZm9ybWF0aW9uLmpzPzU2YTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NoYXJ0Q2xhc3MuanM/MjAyZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvd2Vla0ZvcmVjYXN0Q2xhc3MuanM/MjE1OCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcz85MjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxjQUFjLElBQUksYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CLE1BQU0sbUNBQW1DLGNBQWMsRUFBRTtBQUMvRzs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7O0FDNUZPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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XG4gICAgY29uc3RydWN0b3Iod2VhdGhlckluZm8pIHtcclxuICAgICAgdGhpcy5sb2NhdGlvbiA9IHdlYXRoZXJJbmZvLm5hbWUsXHJcbiAgICAgIHRoaXMuY291bnRyeSA9IHdlYXRoZXJJbmZvLnN5cy5jb3VudHJ5XHJcbiAgICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCksXHJcbiAgICAgIHRoaXMudGVtcCA9IHdlYXRoZXJJbmZvLm1haW4udGVtcCxcclxuICAgICAgdGhpcy5pY29uTmFtZSA9IHdlYXRoZXJJbmZvLndlYXRoZXJbMF0ubWFpbixcclxuICAgICAgdGhpcy5wcmVzc3VyZSA9IHdlYXRoZXJJbmZvLm1haW4ucHJlc3N1cmUsXHJcbiAgICAgIHRoaXMuaHVtaWRpdHkgPSB3ZWF0aGVySW5mby5tYWluLmh1bWlkaXR5LFxyXG4gICAgICB0aGlzLndpbmRTcHBlZCA9IHdlYXRoZXJJbmZvLndpbmQuc3BlZWRcclxuICAgIH1cclxuICBcclxuICAgIHNldExvY2F0aW9uKCkge1xyXG4gICAgICBjb25zdCBsb2NhdGlvbklEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImhlYWRUZXh0X19sb2NhdGlvbi0tanNcIilbMF07XHJcbiAgICAgIGxvY2F0aW9uSUQuaW5uZXJIVE1MID0gYGluICR7dGhpcy5sb2NhdGlvbn0sICR7dGhpcy5jb3VudHJ5fWA7XHJcbiAgICB9XHJcbiAgICBzZXREYXRlKCkge1xyXG4gICAgICBjb25zdCBkYXRlSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaGVhZFRleHRfX2RhdGUtLWpzXCIpWzBdO1xyXG4gICAgICBkYXRlSUQuaW5uZXJIVE1MID0gYFRvZGF5ICR7dGhpcy5kYXRlLmdldERhdGUoKX10aCwgJHt0aGlzLmRhdGUudG9Mb2NhbGVTdHJpbmcoJ2VuLUVOJywge21vbnRoOiAnbG9uZyd9KX1gXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNldFRlbXAoKSB7XHJcbiAgICAgIGNvbnN0IHRlbXBJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJoZWFkVGV4dC0tZGVncmVlcy1qc1wiKVswXTtcclxuICAgICAgdGVtcElELmlubmVySFRNTCA9IGAke3RoaXMudGVtcC50b0ZpeGVkKDEpfSDCsENgO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgc2V0UHJlc3N1cmUoKSB7XHJcbiAgICAgIGNvbnN0IHByZXNzdXJlSUQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwid2VhdGhlclRvZGF5X19wcmVzc3VyZS0tanNcIilbMF07XHJcbiAgICAgIHByZXNzdXJlSUQuaW5uZXJIVE1MID0gYCR7dGhpcy5wcmVzc3VyZX0gaFBhYDtcclxuICAgIH1cclxuICBcclxuICAgIHNldEh1bWlkaXR5KCkge1xyXG4gICAgICBjb25zdCBodW1pZGl0eUlEID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIndlYXRoZXJUb2RheV9faHVtaWRpdHktLWpzXCIpWzBdO1xyXG4gICAgICBodW1pZGl0eUlELmlubmVySFRNTCA9IGAke3RoaXMuaHVtaWRpdHl9ICVgO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgc2V0V2luZFNwZWVkKCkge1xyXG4gICAgICBjb25zdCB3aW5kU3BlZWRJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3ZWF0aGVyVG9kYXlfX3dpbmRTcGVlZC0tanNcIilbMF07XHJcbiAgICAgIHdpbmRTcGVlZElELmlubmVySFRNTCA9IGAke3RoaXMud2luZFNwcGVkfSBtL3NgO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgc2V0V2VhdGhlckluZm9ybWF0aW9uKCkge1xyXG4gICAgICB0aGlzLnNldExvY2F0aW9uKCk7XHJcbiAgICAgIHRoaXMuc2V0RGF0ZSgpO1xyXG4gICAgICB0aGlzLnNldFRlbXAoKTtcclxuICAgICAgdGhpcy5zZXRQcmVzc3VyZSgpO1xyXG4gICAgICB0aGlzLnNldEh1bWlkaXR5KCk7XHJcbiAgICAgIHRoaXMuc2V0V2luZFNwZWVkKCk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICB3ZWF0aGVySWNvbih3ZWF0aGVyKSB7XHJcbiAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgc3dpdGNoKHdlYXRoZXIpIHtcclxuICAgICAgICBjYXNlICd0aHVuZGVyc3Rvcm0nOlxyXG4gICAgICAgICAgcmV0dXJuICdzdG9ybS5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnRHJpenpsZSc6XHJcbiAgICAgICAgICByZXR1cm4gJ0RyaXp6bGUuc3ZnJztcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1JhaW4nOlxyXG4gICAgICAgICAgcmV0dXJuICdSYWluLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdTbm93JzpcclxuICAgICAgICAgIHJldHVybiAnU25vd2ZsYWtlLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdBdG1vc3BoZXJlJzpcclxuICAgICAgICAgIHJldHVybiAnZm9nLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdDbGVhcic6XHJcbiAgICAgICAgICBpZihjdXJyZW50RGF0ZSA8PSAyMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3N1bi5zdmcnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJ21vb24uc3ZnJztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnQ2xvdWRzJzpcclxuICAgICAgICAgIHJldHVybiAnQ2xvdWRzLnN2ZydcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICBzZXRJbWFnZSgpIHtcclxuICAgICAgY29uc3QgaW1hZ2VJRCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3ZWF0aGVySW1hZ2UtLWpzXCIpWzBdO1xyXG4gICAgICBjb25zdCB3ZWF0aGVyTmFtZSA9IHRoaXMud2VhdGhlckljb24odGhpcy5pY29uTmFtZSk7XHJcbiAgICAgIGltYWdlSUQuc3JjID0gYGFzc2V0cy9pbWcvJHt3ZWF0aGVyTmFtZX1gO1xyXG4gICAgfVxyXG4gICAgcm91bmRUZW1wKHRlbXApIHtcclxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHRlbXAgKiAxMDApLzEwMCk7XHJcbiAgICB9XHJcbiAgfSIsImV4cG9ydCBjbGFzcyBDaGFydCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3ZWF0aGVyRGF0YSwgYXhpc1hwb3NpdGlvbikge1xyXG4gICAgICB0aGlzLmF4aXNYcG9zaXRpb24gPSBheGlzWHBvc2l0aW9uO1xyXG4gICAgICB0aGlzLndlYXRoZXJCeUhvdXIgPSB3ZWF0aGVyRGF0YTtcclxuICAgICAgdGhpcy5jb25kaXRpb24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xyXG4gICAgICB0aGlzLnRvb2x0aXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiY2hhcnRUZW1wX190b29sdGlwXCIpWzBdO1xyXG4gICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hhcnRUZW1wX19jYW52YXNcIik7XHJcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgY2FudmFzRGltZW5zaW9ucygpIHtcclxuICAgICAgdGhpcy5jYW52YXMud2lkdGggPSA2NjA7XHJcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IDMwOTtcclxuICAgIH1cclxuICBcclxuICAgIGJsb2Nrcyhjb3VudCkge1xyXG4gICAgICByZXR1cm4gY291bnQgKiA0MDtcclxuICAgIH1cclxuICBcclxuICAgIGRyYXdHcmlkKCkge1xyXG4gICAgICBsZXQgZ3JpZFggPSA0MDtcclxuICAgICAgbGV0IGdyaWRZID0gNDA7XHJcbiAgICAgIGNvbnN0IGNlbGxTaXplID0gNDA7XHJcbiAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IFwibGlnaHRncmV5XCI7XHJcbiAgICBcclxuICAgICAgd2hpbGUgKGdyaWRYIDw9IHRoaXMuY2FudmFzLndpZHRoIC0gMjApIHtcclxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oZ3JpZFgsIDIwKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lVG8oZ3JpZFgsIHRoaXMuY2FudmFzLmhlaWdodCAtIDIwKTtcclxuICAgICAgICBncmlkWCArPSBjZWxsU2l6ZTtcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAoZ3JpZFkgPD0gdGhpcy5jYW52YXMuaGVpZ2h0IC0gMjApIHtcclxuICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oMjAsIGdyaWRZKTtcclxuICAgICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5jYW52YXMud2lkdGggLSAxMCwgZ3JpZFkpO1xyXG4gICAgICAgIGdyaWRZICs9IGNlbGxTaXplO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgYXN5bmMgZHJhd0F4aXMoaG91cnMpIHtcclxuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xyXG4gICAgICB0aGlzLmN0eC5tb3ZlVG8odGhpcy5ibG9ja3MoMSksIHRoaXMuYmxvY2tzKDEgLyAyKSk7XHJcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyh0aGlzLmJsb2NrcygxKSwgdGhpcy5ibG9ja3MoNykpO1xyXG4gICAgICB0aGlzLmN0eC5saW5lVG8odGhpcy5ibG9ja3MoMTYpLCB0aGlzLmJsb2Nrcyg3KSk7XHJcbiAgICBcclxuICAgICAgdGhpcy5jdHgubW92ZVRvKHRoaXMuYmxvY2tzKDEpLCB0aGlzLmJsb2Nrcyg3KSk7XHJcbiAgICAgIGxldCB0ZXh0ID0gMDtcclxuICAgICAgbGV0IHRleHRZID0gdGhpcy5ibG9ja3MoNyk7XHJcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDc7IGkrKykge1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVRleHQodGV4dCwgdGhpcy5ibG9ja3MoMSAvIDIpLCB0ZXh0WSk7XHJcbiAgICAgICAgdGV4dFkgLT0gNDA7XHJcbiAgICAgICAgdGV4dCArPSA1O1xyXG4gICAgICB9XHJcbiAgICBcclxuICAgICAgdGhpcy5jdHgubW92ZVRvKHRoaXMuYmxvY2tzKDIpLCB0aGlzLmJsb2Nrcyg3KSk7XHJcbiAgICAgIGxldCB0ZXh0WCA9IHRoaXMuYmxvY2tzKDEuOSk7XHJcbiAgICBcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTU7IGkrKykge1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVRleHQoaG91cnNbaV0sIHRleHRYLCB0aGlzLmJsb2Nrcyg3LjUpKTtcclxuICAgICAgICB0ZXh0WCArPSA0MDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuICAgIHRpbWVzdGFtcFRvVGltZShzdGFtcCkge1xyXG4gICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHN0YW1wICogMTAwMCk7XHJcbiAgICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIG1hcEFuZEZpbHRlcih0ZW1wQXJyYXkpIHtcclxuICAgICAgdGVtcEFycmF5ID0gdGVtcEFycmF5Lm1hcCgoZWwpID0+IHRoaXMudGltZXN0YW1wVG9UaW1lKGVsKSk7XHJcbiAgICAgIHRlbXBBcnJheSA9IHRlbXBBcnJheS5maWx0ZXIoKGVsKSA9PiBlbCAlIDIgPT0gMCk7XHJcbiAgICAgIHJldHVybiB0ZW1wQXJyYXk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRlbXBlcmF0dXJlVG9DaGFydENvb3Jkcyh0ZW1wKXtcclxuICAgICAgbGV0IHRlbXBlcmF0dXJlID0gdGVtcC5tYXAoKGVsKSA9PiBlbCAvIDUpO1xyXG4gICAgICB0ZW1wZXJhdHVyZSA9IHRlbXBlcmF0dXJlLnNsaWNlKDAsMTUpO1xyXG4gICAgICByZXR1cm4gdGVtcGVyYXR1cmU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdldEhvdXJzQ29vcmRzKCkge1xyXG4gICAgICBsZXQgaG91ck9mVGVtcCA9IFsuLi5BcnJheSgxNykua2V5cygpXVxyXG4gICAgICBob3VyT2ZUZW1wID0gaG91ck9mVGVtcC5zbGljZSgyLCAxNyk7XHJcbiAgICBcclxuICAgICAgcmV0dXJuIGhvdXJPZlRlbXA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGRyYXdDaGFydCh0ZW1wZXJhdHVyZSkge1xyXG4gICAgICBjb25zdCB0ZW1wSG91cnMgPSB0aGlzLmdldEhvdXJzQ29vcmRzKCk7XHJcbiAgICAgIGxldCBpID0gMTtcclxuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY3R4XHJcbiAgICAgIGNvbnN0IGJsb2NrID0gdGhpcy5ibG9ja3MuYmluZCh0aGlzKTtcclxuICAgICAgY29uc3QgYXhpc1hwb3NpdGlvbiA9IHRoaXMuYXhpc1hwb3NpdGlvbjtcclxuICAgICAgZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xyXG4gICAgICAgIGlmIChpIDw9IHRlbXBlcmF0dXJlLmxlbmd0aCkge1xyXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCIjRkZFNzRBXCI7XHJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAzO1xyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oYmxvY2sodGVtcEhvdXJzW2ktMV0pLCBheGlzWHBvc2l0aW9uIC0gYmxvY2sodGVtcGVyYXR1cmVbaS0xXSkpO1xyXG4gICAgICAgIGNvbnRleHQuYXJjKGJsb2NrKHRlbXBIb3Vyc1tpLTFdKSwgYXhpc1hwb3NpdGlvbiAtIGJsb2NrKHRlbXBlcmF0dXJlW2ktMV0pLCAzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XHJcbiAgICAgICAgY29udGV4dC5saW5lVG8oYmxvY2sodGVtcEhvdXJzW2ldKSwgYXhpc1hwb3NpdGlvbiAtIGJsb2NrKHRlbXBlcmF0dXJlW2ldKSk7XHJcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcclxuICAgICAgICBpKys7XHJcbiAgICAgIH1cclxuICAgICAgYW5pbWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGFzeW5jIHdhaXRGb3JHcmlkKG1zKSB7XHJcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgbXMpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZ2V0TW91c2VQb3NpdGlvbihldnQpIHtcclxuICAgICAgbGV0IHJlY3QgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB4OiBldnQuY2xpZW50WCAtIHJlY3QubGVmdCxcclxuICAgICAgICB5OiBldnQuY2xpZW50WSAtIHJlY3QudG9wXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZpbHRlclRlbXBlcmF0dXJlKHRlbXBlcmF0dXJlKSB7XHJcbiAgICAgIGNvbnN0IHRlbXAgPSB0ZW1wZXJhdHVyZVxyXG4gICAgICAgIC5tYXAoKG9iaikgPT4gb2JqLnRlbXApXHJcbiAgICAgICAgLmZpbHRlcigoZWwsIGluZGV4KSA9PiBpbmRleCAlIDIgPT0gMCk7XHJcbiAgICBcclxuICAgICAgcmV0dXJuIHRlbXA7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRlbXBlcmF0dXJlVG9QaXhlbCh0ZW1wKXtcclxuICAgICAgdGVtcCA9IHRlbXAubWFwKGVsID0+IHRoaXMuYXhpc1hwb3NpdGlvbiAtIHRoaXMuYmxvY2tzKGVsKSk7XHJcbiAgICAgIHJldHVybiB0ZW1wO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBob3Vyc1RvUGl4ZWwoaG91cnMpIHtcclxuICAgICAgY29uc3QgaG91cnJzID0gaG91cnMubWFwKGVsID0+IHRoaXMuYmxvY2tzKGVsKSk7XHJcbiAgICAgIHJldHVybiBob3VycnM7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNyZWF0ZVRlbXBPYmooaG91ciwgdGVtcCwgaG91ck9mVGVtcCwgdGVtcEluSG91cil7XHJcbiAgICAgIGNvbnN0IHRlbXBQb2ludENvb3JkcyA9IFtdO1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIHRlbXBQb2ludENvb3Jkcy5wdXNoKHtcclxuICAgICAgICAgIHg6IGhvdXJbaV0sXHJcbiAgICAgICAgICB5OiB0ZW1wW2ldLFxyXG4gICAgICAgICAgeG1pbjogaG91cltpXSAtIDMsXHJcbiAgICAgICAgICB4bWF4OiBob3VyW2ldICsgMyxcclxuICAgICAgICAgIHltaW46IHRlbXBbaV0gLSAzLFxyXG4gICAgICAgICAgeW1heDogdGVtcFtpXSArIDMsXHJcbiAgICAgICAgICBob3VyVGVtcDoge1xyXG4gICAgICAgICAgICBob3VyOiBob3VyT2ZUZW1wW2ldLFxyXG4gICAgICAgICAgICB0ZW1wOiB0ZW1wSW5Ib3VyW2ldXHJcbiAgICAgICAgICB9LFxyXG4gICAgXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGVtcFBvaW50Q29vcmRzO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkcmF3UG9pbnQoY29vcmRzID0ge30sIHJhZGl1cywgY29sb3IgPSAnd2hpdGUnKSB7XHJcbiAgICAgIGNvbnN0IG1vdXNlQ29vcmRpbmF0ZSA9IGNvb3JkcztcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIHRoaXMuY3R4Lm1vdmVUbyhtb3VzZUNvb3JkaW5hdGUueCwgbW91c2VDb29yZGluYXRlLnkpO1xyXG4gICAgICB0aGlzLmN0eC5hcmMobW91c2VDb29yZGluYXRlLngsIG1vdXNlQ29vcmRpbmF0ZS55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgICAgIHRoaXMuY3R4LmZpbGwoKTtcclxuICAgICAgdGhpcy5jdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICBcclxuICAgIGFkZFBvcFVwKHRlbXBQb2ludCkge1xyXG4gICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1vdXNlQ29vcmRzID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGUpO1xyXG4gICAgICAgIGxldCBib29vbHMgPSB0ZW1wUG9pbnQuZmlsdGVyKGVsID0+IHtcclxuICAgICAgICAgIGNvbnN0IGEgPSBlbC54bWluIDw9IG1vdXNlQ29vcmRzLng7XHJcbiAgICAgICAgICBjb25zdCBiID0gbW91c2VDb29yZHMueCA8PSBlbC54bWF4O1xyXG4gICAgICAgICAgY29uc3QgYyA9IGVsLnltaW4gPD0gbW91c2VDb29yZHMueTtcclxuICAgICAgICAgIGNvbnN0IGQgPSBtb3VzZUNvb3Jkcy55IDw9IGVsLnltYXg7XHJcbiAgICAgICAgICByZXR1cm4gKGEgJiYgYiAmJiBjICYmIGQpfSlcclxuICAgICAgICBcclxuICAgICAgICBpZihib29vbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLmRyYXdQb2ludChib29vbHNbMF0sIDEpO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHsuLi5ib29vbHNbMF19O1xyXG4gICAgICAgICAgdGhpcy5jb25kaXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKHRoaXMuY2FudmFzLndpZHRoIC0gKHRoaXMuc3RhdGUueCArIDUpIDw9IDgwKXtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLmxlZnQgPSBgJHt0aGlzLnN0YXRlLnggLSA4NX1weGBcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLnRvcCA9IGAke3RoaXMuc3RhdGUueSAtIDM1fXB4YDtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLmxlZnQgPSBgJHt0aGlzLnN0YXRlLnggKyA1fXB4YDtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLnRvcCA9IGAke3RoaXMuc3RhdGUueSAtIDM1fXB4YDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgICAgdGhpcy50b29sdGlwLmlubmVySFRNTCA9IGBUaW1lOiAke3RoaXMuc3RhdGUuaG91clRlbXAuaG91cn06MDAsIFRlbXA6ICR7dGhpcy5zdGF0ZS5ob3VyVGVtcC50ZW1wfcKwQ2A7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIGlmKCFib29vbHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLmRyYXdQb2ludCh0aGlzLnN0YXRlLCAzLCBcIiNGRkU3NEFcIik7XHJcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xyXG4gICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfSBcclxuICAgICAgfSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgYXN5bmMgY2hhcnQoKSB7XHJcbiAgICAgIGNvbnN0IGhvdXJPZldlYXRoZXIgPSB0aGlzLm1hcEFuZEZpbHRlcih0aGlzLndlYXRoZXJCeUhvdXIubWFwKChvYmopID0+IG9iai5kdCkpO1xyXG4gICAgICBsZXQgdGVtcGVyYXR1cmUgPSB0aGlzLmZpbHRlclRlbXBlcmF0dXJlKHRoaXMud2VhdGhlckJ5SG91cik7XHJcbiAgICAgIGNvbnN0IHRlbXBlcmF0dXJlQ29vcmRzID0gdGhpcy50ZW1wZXJhdHVyZVRvQ2hhcnRDb29yZHModGVtcGVyYXR1cmUpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdGVtcFBpeGVscyA9IHRoaXMudGVtcGVyYXR1cmVUb1BpeGVsKHRlbXBlcmF0dXJlQ29vcmRzLCB0aGlzLmF4aXNYcG9zaXRpb24pO1xyXG4gICAgICBjb25zdCBob3Vyc1BpeGVscyA9IHRoaXMuaG91cnNUb1BpeGVsKHRoaXMuZ2V0SG91cnNDb29yZHMoKSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0ZW1wUG9pbnRzID0gdGhpcy5jcmVhdGVUZW1wT2JqKGhvdXJzUGl4ZWxzLCB0ZW1wUGl4ZWxzLCBob3VyT2ZXZWF0aGVyLCB0ZW1wZXJhdHVyZSk7XHJcbiAgICBcclxuICAgICAgdGhpcy5jYW52YXNEaW1lbnNpb25zKCk7XHJcbiAgICAgIHRoaXMuZHJhd0dyaWQoKTtcclxuICAgICAgdGhpcy5kcmF3QXhpcyhob3VyT2ZXZWF0aGVyKTtcclxuICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yR3JpZCg1MDApO1xyXG4gICAgICB0aGlzLmRyYXdDaGFydCh0ZW1wZXJhdHVyZUNvb3JkcylcclxuICAgICAgdGhpcy5hZGRQb3BVcCh0ZW1wUG9pbnRzKTtcclxuICAgIH1cclxuICBcclxuICB9IiwiZXhwb3J0IGNsYXNzIFdlZWtGb3JlY2FzdCB7XHJcbiAgY29uc3RydWN0b3Iod2Vla0ZvcmVjYXN0RGF0YSkge1xyXG4gICAgdGhpcy53ZWVrRGF0YSA9IHdlZWtGb3JlY2FzdERhdGE7XHJcbiAgICB0aGlzLndlYXRoZXJGb3JlY2FzdENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ3ZWF0aGVyRm9yZWNhc3QtLWpzXCIpO1xyXG4gICAgdGhpcy53ZWF0aGVyRm9yZWNhc3RDb250YWluZXIgPSB0aGlzLndlYXRoZXJGb3JlY2FzdENvbnRhaW5lclswXTtcclxuICB9XHJcblxyXG4gIHNsaWNlV2Vla0RhdGFBcnJheSgpe1xyXG4gICAgdGhpcy53ZWVrRGF0YSA9IHRoaXMud2Vla0RhdGEuc2xpY2UoMSw4KTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMud2Vla0RhdGEpXHJcbiAgfVxyXG4gIGdldFRpbWVzdGFtcFRvVGltZSh0aW1lc3RhbXApIHtcclxuICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwKTtcclxuICAgIHJldHVybiB0aW1lLmdldERheSgpO1xyXG4gIH1cclxuICBnZXROYW1lT2ZXZWVrKG51bWJlcikge1xyXG4gICAgc3dpdGNoIChudW1iZXIpIHtcclxuICAgICAgY2FzZSAwOlxyXG4gICAgICAgIHJldHVybiBcIlN1blwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDE6XHJcbiAgICAgICAgcmV0dXJuIFwiTW9uXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgMjpcclxuICAgICAgICByZXR1cm4gXCJUdWVcIjtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAzOlxyXG4gICAgICAgIHJldHVybiBcIldlZFwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDQ6XHJcbiAgICAgICAgcmV0dXJuIFwiVGh1clwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDU6IFxyXG4gICAgICAgIHJldHVybiBcIkZyaVwiO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIDY6XHJcbiAgICAgICAgcmV0dXJuIFwiU2F0XCI7XHJcbiAgICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcbiAgZ2V0V2VhdGhlclBhcmFtZXRlcnMoKXtcclxuICAgIHRoaXMud2Vla0RhdGEgPSB0aGlzLndlZWtEYXRhLm1hcChlbCA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZGF5OiB0aGlzLmdldE5hbWVPZldlZWsodGhpcy5nZXRUaW1lc3RhbXBUb1RpbWUoZWwuZHQpKSwgXHJcbiAgICAgICAgdGVtcDogZWwudGVtcC5kYXksXHJcbiAgICAgICAgd2VhdGhlcjogZWwud2VhdGhlclswXS5tYWluXHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2codGhpcy53ZWVrRGF0YSlcclxuICB9XHJcblxyXG4gIHB1dFdlYXRoZXJJbnRvU2VjdGlvbigpe1xyXG4gICAgdGhpcy53ZWF0aGVyRm9yZWNhc3RDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB0aGlzLndlZWtEYXRhLmZvckVhY2goZWwgPT4ge1xyXG4gICAgICB0aGlzLndlYXRoZXJGb3JlY2FzdENvbnRhaW5lci5pbm5lckhUTUwgKz0gYDxkaXYgY2xhc3M9XCJ3ZWF0aGVyRm9yZWNhc3RfX2RheSB3ZWF0aGVyRm9yZWNhc3RfX2RheS0tanNcIj48aW1nIGNsYXNzPVwid2VhdGhlckZvcmVjYXN0X19kYXlFbGVtZW50XCIgc3JjPScvYXNzZXRzL2ltZy93ZWF0aGVyaWNvbnMvJHt0aGlzLndlYXRoZXJJY29uKGVsLndlYXRoZXIpfScgYWx0PScnPjwvaW1nPjxkaXYgY2xhc3M9XCJ3ZWF0aGVyRm9yZWNhc3RfX2RheUVsZW1lbnRcIj48cD4ke2VsLmRheX08YnI+JHtlbC50ZW1wfTwvcD48L2Rpdj48L2Rpdj5gXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgYWRkV2VhdGhlckZvcmVjYXN0KCkge1xyXG4gICAgdGhpcy5zbGljZVdlZWtEYXRhQXJyYXkoKTtcclxuICAgIHRoaXMuZ2V0V2VhdGhlclBhcmFtZXRlcnMoKTtcclxuICAgIHRoaXMucHV0V2VhdGhlckludG9TZWN0aW9uKCk7XHJcbiAgfVxyXG5cclxuICB3ZWF0aGVySWNvbih3ZWF0aGVyKSB7XHJcbiAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZS5nZXRIb3VycygpO1xyXG4gICAgc3dpdGNoKHdlYXRoZXIpIHtcclxuICAgICAgY2FzZSAndGh1bmRlcnN0b3JtJzpcclxuICAgICAgICByZXR1cm4gJ3N0b3JtLnN2Zyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ0RyaXp6bGUnOlxyXG4gICAgICAgIHJldHVybiAnRHJpenpsZS5zdmcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdSYWluJzpcclxuICAgICAgICByZXR1cm4gJ1JhaW4uc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnU25vdyc6XHJcbiAgICAgICAgcmV0dXJuICdTbm93Zmxha2Uuc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQXRtb3NwaGVyZSc6XHJcbiAgICAgICAgcmV0dXJuICdmb2cuc3ZnJztcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQ2xlYXInOlxyXG4gICAgICAgIGlmKGN1cnJlbnREYXRlIDw9IDIwKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ3N1bi5zdmcnO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuICdtb29uLnN2Zyc7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIGNhc2UgJ0Nsb3Vkcyc6XHJcbiAgICAgICAgcmV0dXJuICdDbG91ZHMuc3ZnJ1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0iLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IHtXZWF0aGVySW5mb3JtYXRpb259IGZyb20gJy4vd2VhdGhlckluZm9ybWF0aW9uLmpzJztcclxuaW1wb3J0IHtDaGFydH0gZnJvbSAnLi9jaGFydENsYXNzLmpzJztcclxuaW1wb3J0IHtXZWVrRm9yZWNhc3R9IGZyb20gJy4vd2Vla0ZvcmVjYXN0Q2xhc3MuanMnXHJcbi8vIHNlcnZpY2Ugd29ya2VyIHJlZ2lzdHJhdGlvbiAtIHJlbW92ZSBpZiB5b3UncmUgbm90IGdvaW5nIHRvIHVzZSBpdFxyXG5cclxuaWYgKFwic2VydmljZVdvcmtlclwiIGluIG5hdmlnYXRvcikge1xyXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5yZWdpc3RlcihcInNlcnZpY2V3b3JrZXIuanNcIikudGhlbihcclxuICAgICAgZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgIC8vIFJlZ2lzdHJhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICAgXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBzdWNjZXNzZnVsIHdpdGggc2NvcGU6IFwiLFxyXG4gICAgICAgICAgcmVnaXN0cmF0aW9uLnNjb3BlXHJcbiAgICAgICAgKTtcclxuICAgICAgfSxcclxuICAgICAgZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgIC8vIHJlZ2lzdHJhdGlvbiBmYWlsZWQgOihcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlNlcnZpY2VXb3JrZXIgcmVnaXN0cmF0aW9uIGZhaWxlZDogXCIsIGVycik7XHJcbiAgICAgIH1cclxuICAgICk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbi8vIHBsYWNlIHlvdXIgY29kZSBiZWxvd1xyXG5jb25zdCBhcGlLZXkgPSBcIjUzYzVlOTc2NzVjOGQzZDhkYTA3ZTU2YWVjNWEzYTIyXCI7XHJcbmNvbnN0IGF4aXNYcG9zaXRpb24gPSAyODA7IC8vIFggYXhpcyBpcyBvbiAyODBweCBDYW52YXMgSGVpZ2h0O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgbGFzdFRpbWUgPSAwO1xyXG4gIHZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcclxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gIH1cclxuXHJcbiAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBlbGVtZW50KSB7XHJcbiAgICAgIHZhciBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcclxuICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcclxuICAgICAgfSxcclxuICAgICAgdGltZVRvQ2FsbCk7XHJcbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICByZXR1cm4gaWQ7XHJcbiAgfTtcclxuXHJcbiAgaWYgKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gIH07XHJcbn0oKSk7XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIHN1Y2Nlc3MobG9jKSB7XHJcbiAgY29uc3QgeyBjb29yZHMgfSA9IGxvYztcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3IoZXJyKSB7XHJcbiAgY29uc29sZS53YXJuKGBFUlJPUigke2Vyci5jb2RlfSk6ICR7ZXJyLm1lc3NhZ2V9YCk7XHJcbn1cclxuXHJcbmNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgZW5hYmxlSGlnaEFjY3VyYWN5OiB0cnVlLFxyXG4gIHRpbWVvdXQ6IDUwMDAsXHJcbiAgbWF4aW11bUFnZTogMCxcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbnNvbFZhbHVlKHZhbCkge1xyXG4gIHJldHVybiB2YWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvY2F0aW9uKCkge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxyXG4gICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihyZXNvbHZlLCBlcnJvcilcclxuICApO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBnZXRMb2NhdGlvbihsb2NhdGlvbikge1xyXG4gIGxldCBwb3NpdGlvbiA9IGxvY2F0aW9uO1xyXG4gIGxldCB3ZWF0aGVyQnlQb3NpdGlvbjtcclxuICBsZXQgd2VhdGhlckJ5SG91cjtcclxuICBsZXQgbmV4dFNldmVuRGF5cztcclxuICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSAnb2JqZWN0Jykge1xyXG4gICAgXHJcbiAgICBwb3NpdGlvbiA9IGF3YWl0IHBvc2l0aW9uLmNvb3JkcztcclxuICAgIGNvbnN0IHsgbGF0aXR1ZGUsIGxvbmdpdHVkZSB9ID0gcG9zaXRpb247XHJcbiAgXHJcbiAgICB3ZWF0aGVyQnlQb3NpdGlvbiA9IGF3YWl0IGZldGNoKFxyXG4gICAgICBgaHR0cHM6Ly9hcGkub3BlbndlYXRoZXJtYXAub3JnL2RhdGEvMi41L3dlYXRoZXI/bGF0PSR7bGF0aXR1ZGV9Jmxvbj0ke2xvbmdpdHVkZX0mYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpYyZsYW5nPXBsYFxyXG4gICAgKTtcclxuICAgIHdlYXRoZXJCeVBvc2l0aW9uID0gYXdhaXQgd2VhdGhlckJ5UG9zaXRpb24uanNvbigpO1xyXG4gICAgXHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2xhdGl0dWRlfSZsb249JHtsb25naXR1ZGV9JlxyXG4gICAgZXhjbHVkZT1ob3VybHkmYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApO1xyXG4gICAgd2VhdGhlckJ5SG91ciA9IGF3YWl0IHdlYXRoZXJCeUhvdXIuanNvbigpO1xyXG4gICAgd2VhdGhlckJ5SG91ciA9IHdlYXRoZXJCeUhvdXIuaG91cmx5O1xyXG4gICAgXHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2xhdGl0dWRlfSZsb249JHtsb25naXR1ZGV9JlxyXG4gICAgZXhjbHVkZT1kYWlseSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljYClcclxuICAgIG5leHRTZXZlbkRheXMgPSBhd2FpdCBuZXh0U2V2ZW5EYXlzLmpzb24oKTtcclxuICAgIG5leHRTZXZlbkRheXMgPSBuZXh0U2V2ZW5EYXlzLmRhaWx5O1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHdlYXRoZXJCeVBvc2l0aW9uID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS93ZWF0aGVyP3E9JHtwb3NpdGlvbn0mYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApXHJcbiAgICB3ZWF0aGVyQnlQb3NpdGlvbiA9IGF3YWl0IHdlYXRoZXJCeVBvc2l0aW9uLmpzb24oKTtcclxuICAgIFxyXG4gICAgY29uc3QgY29vcmRzID0gd2VhdGhlckJ5UG9zaXRpb24uY29vcmQ7XHJcbiAgICBjb25zb2xlLmxvZyhjb29yZHMpXHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vYXBpLm9wZW53ZWF0aGVybWFwLm9yZy9kYXRhLzIuNS9vbmVjYWxsP2xhdD0ke2Nvb3Jkcy5sYXR9Jmxvbj0ke2Nvb3Jkcy5sb259JlxyXG4gICAgZXhjbHVkZT1ob3VybHkmYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApO1xyXG4gICAgd2VhdGhlckJ5SG91ciA9IGF3YWl0IHdlYXRoZXJCeUhvdXIuanNvbigpO1xyXG4gICAgXHJcbiAgICB3ZWF0aGVyQnlIb3VyID0gd2VhdGhlckJ5SG91ci5ob3VybHk7XHJcblxyXG4gICAgbmV4dFNldmVuRGF5cyA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvb25lY2FsbD9sYXQ9JHtjb29yZHMubGF0fSZsb249JHtjb29yZHMubG9ufSZcclxuICAgIGV4Y2x1ZGU9ZGFpbHkmYXBwaWQ9JHthcGlLZXl9JnVuaXRzPW1ldHJpY2ApXHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gYXdhaXQgbmV4dFNldmVuRGF5cy5qc29uKCk7XHJcbiAgICBuZXh0U2V2ZW5EYXlzID0gbmV4dFNldmVuRGF5cy5kYWlseTtcclxuICB9XHJcbiAgXHJcblxyXG5cclxuICBjb25zdCB3ZWF0aGVyRGF0YSA9IG5ldyBXZWF0aGVySW5mb3JtYXRpb24od2VhdGhlckJ5UG9zaXRpb24pO1xyXG4gIHdlYXRoZXJEYXRhLnNldFdlYXRoZXJJbmZvcm1hdGlvbigpO1xyXG4gIGNvbnN0IGNoYXJ0ID0gbmV3IENoYXJ0KHdlYXRoZXJCeUhvdXIsIGF4aXNYcG9zaXRpb24pO1xyXG4gIGNoYXJ0LmNoYXJ0KCk7XHJcbiAgY29uc3QgZm9yZWNhc3RGb3JXZWVrID0gbmV3IFdlZWtGb3JlY2FzdChuZXh0U2V2ZW5EYXlzKTtcclxuICBmb3JlY2FzdEZvcldlZWsuYWRkV2VhdGhlckZvcmVjYXN0KCk7XHJcbiAgXHJcbn1cclxuXHJcbmNvbnN0IGxvY2FsaXphdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hlYWRlcl9fZ2VvbG9jYWxpemF0aW9uLS1idXR0b25KUycpWzBdO1xyXG5jb25zdCBzZWFyY2hCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdoZWFkZXJfX3NlYXJjaC0tYnV0dG9uSlMnKVswXTtcclxuY29uc3QgaW5wdXRGaWVsZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2hlYWRlcl9fc2VhcmNoLS1pbnB1dEpTJylbMF07XHJcblxyXG5cclxubG9jYWxpemF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IGxvY2F0aW9ucyA9IGF3YWl0IGxvY2F0aW9uKCk7XHJcbiAgZ2V0TG9jYXRpb24obG9jYXRpb25zKTtcclxufSlcclxuXHJcbnNlYXJjaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICBpZiAoIWlucHV0RmllbGQudmFsdWUpIHtcclxuICAgIGFsZXJ0KFwicGxlYXNlIHR5cGUgeW91ciBjaXR5IG5hbWVcIik7XHJcbiAgfVxyXG4gIGVsc2UgaWYgKGlucHV0RmllbGQudmFsdWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGdldExvY2F0aW9uKGlucHV0RmllbGQudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2goZXJyb3IpIHtcclxuICAgICAgYWxlcnQoJ1BsZWFzZSB0eXBlIGNvcnJldCBjaXR5IG5hbWUnKVxyXG4gICAgfVxyXG4gIH1cclxufSkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")}]);