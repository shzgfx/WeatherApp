!function(c){var t={};function n(r){if(t[r])return t[r].exports;var l=t[r]={i:r,l:!1,exports:{}};return c[r].call(l.exports,l,l.exports,n),l.l=!0,l.exports}n.m=c,n.c=t,n.d=function(c,t,r){n.o(c,t)||Object.defineProperty(c,t,{enumerable:!0,get:r})},n.r=function(c){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(c,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(c,"__esModule",{value:!0})},n.t=function(c,t){if(1&t&&(c=n(c)),8&t)return c;if(4&t&&"object"==typeof c&&c&&c.__esModule)return c;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:c}),2&t&&"string"!=typeof c)for(var l in c)n.d(r,l,function(t){return c[t]}.bind(null,l));return r},n.n=function(c){var t=c&&c.__esModule?function(){return c.default}:function(){return c};return n.d(t,"a",t),t},n.o=function(c,t){return Object.prototype.hasOwnProperty.call(c,t)},n.p="",n(n.s=0)}([function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\n// service worker registration - remove if you\'re not going to use it\r\n\r\nif ("serviceWorker" in navigator) {\r\n  window.addEventListener("load", function () {\r\n    navigator.serviceWorker.register("serviceworker.js").then(\r\n      function (registration) {\r\n        // Registration was successful\r\n        console.log(\r\n          "ServiceWorker registration successful with scope: ",\r\n          registration.scope\r\n        );\r\n      },\r\n      function (err) {\r\n        // registration failed :(\r\n        console.log("ServiceWorker registration failed: ", err);\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\n// place your code below\r\nconst apiKey = "53c5e97675c8d3d8da07e56aec5a3a22";\r\n\r\n\r\n(function () {\r\n  var lastTime = 0;\r\n  var vendors = [\'ms\', \'moz\', \'webkit\', \'o\'];\r\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n      window.requestAnimationFrame = window[vendors[x] + \'RequestAnimationFrame\'];\r\n      window.cancelAnimationFrame = window[vendors[x] + \'CancelAnimationFrame\'] || window[vendors[x] + \'CancelRequestAnimationFrame\'];\r\n  }\r\n\r\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {\r\n      var currTime = new Date().getTime();\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n      var id = window.setTimeout(function () {\r\n          callback(currTime + timeToCall);\r\n      },\r\n      timeToCall);\r\n      lastTime = currTime + timeToCall;\r\n      return id;\r\n  };\r\n\r\n  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {\r\n      clearTimeout(id);\r\n  };\r\n}());\r\n\r\n\r\n\r\nfunction success(loc) {\r\n  const { coords } = loc;\r\n}\r\n\r\nfunction error(err) {\r\n  console.warn(`ERROR(${err.code}): ${err.message}`);\r\n}\r\n\r\nconst options = {\r\n  enableHighAccuracy: true,\r\n  timeout: 5000,\r\n  maximumAge: 0,\r\n};\r\n\r\nfunction consolValue(val) {\r\n  return val;\r\n}\r\n\r\nfunction location() {\r\n  return new Promise((resolve, reject) =>\r\n    navigator.geolocation.getCurrentPosition(resolve, error)\r\n  );\r\n}\r\n\r\nasync function getLocation() {\r\n  let position = await location();\r\n  position = await position.coords;\r\n  const { latitude, longitude } = position;\r\n\r\n  let weatherByPosition = await fetch(\r\n    `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}&units=metric&lang=pl`\r\n  );\r\n  let weatherByHour = await fetch(`https://api.openweathermap.org/data/2.5/onecall?lat=${latitude}&lon=${longitude}&\r\n  exclude=hourly&appid=${apiKey}&units=metric&lang=pl`);\r\n  weatherByPosition = await weatherByPosition.json();\r\n  weatherByHour = await weatherByHour.json();\r\n  weatherByHour = weatherByHour.hourly;\r\n  const hourOfWeather = mapAndFilter(weatherByHour.map((obj) => obj.dt));\r\n  let temperature = filterTemperature(weatherByHour);\r\n  const temperatureCoords = temperatureToChartCoords(temperature);\r\n  \r\n  const tempPixels = temperatureToPixel(temperatureCoords);\r\n  const hoursPixels = hoursToPixel(getHoursCoords());\r\n  \r\n  const tempPoints = createTempObj(hoursPixels, tempPixels, hourOfWeather, temperature);\r\n\r\n  \r\n  \r\n\r\n  \r\n  \r\n  grid();\r\n  drawAxis(hourOfWeather);\r\n  await wait(500);\r\n  drawChart(temperatureCoords)\r\n  addPopUp(tempPoints);\r\n}\r\n\r\n\r\n\r\nconst canvas = document.getElementById("chartTemp__canvas");\r\ncanvas.width = 660;\r\ncanvas.height = 309;\r\nconst ctx = canvas.getContext("2d");\r\n\r\nfunction grid() {\r\n  let gridX = 40;\r\n  let gridY = 40;\r\n  const cellSize = 40;\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = "lightgrey";\r\n\r\n  while (gridX <= canvas.width - 20) {\r\n    ctx.moveTo(gridX, 20);\r\n    ctx.lineTo(gridX, canvas.height - 20);\r\n    gridX += cellSize;\r\n  }\r\n  while (gridY <= canvas.height - 20) {\r\n    ctx.moveTo(20, gridY);\r\n    ctx.lineTo(canvas.width - 10, gridY);\r\n    gridY += cellSize;\r\n  }\r\n  ctx.stroke();\r\n}\r\n\r\nfunction blocks(count) {\r\n  return count * 40;\r\n}\r\n\r\nasync function drawAxis(hours) {\r\n  ctx.beginPath();\r\n  ctx.strokeStyle = "black";\r\n  ctx.moveTo(blocks(1), blocks(1 / 2));\r\n  ctx.lineTo(blocks(1), blocks(7));\r\n  ctx.lineTo(blocks(16), blocks(7));\r\n\r\n  ctx.moveTo(blocks(1), blocks(7));\r\n  let text = 0;\r\n  let textY = blocks(7);\r\n  for (let i = 1; i <= 7; i++) {\r\n    ctx.strokeText(text, blocks(1 / 2), textY);\r\n    textY -= 40;\r\n    text += 5;\r\n  }\r\n\r\n  ctx.moveTo(blocks(2), blocks(7));\r\n  let textX = blocks(1.9);\r\n\r\n  for (let i = 0; i <= 15; i++) {\r\n    ctx.strokeText(hours[i], textX, blocks(7.5));\r\n    textX += 40;\r\n  }\r\n  ctx.stroke();\r\n}\r\nfunction timestampToTime(stamp) {\r\n  let date = new Date(stamp * 1000);\r\n  return date.getHours();\r\n}\r\n\r\nfunction mapAndFilter(tempArray) {\r\n  tempArray = tempArray.map((el) => timestampToTime(el));\r\n  tempArray = tempArray.filter((el) => el % 2 == 0);\r\n  return tempArray;\r\n}\r\n\r\nfunction temperatureToChartCoords(temp){\r\n  let temperature = temp.map((el) => el / 5);\r\n  temperature = temperature.slice(0,15);\r\n  return temperature;\r\n}\r\n\r\nfunction getHoursCoords() {\r\n  let hourOfTemp = [...Array(17).keys()]\r\n  hourOfTemp = hourOfTemp.slice(2, 17);\r\n\r\n  return hourOfTemp;\r\n}\r\n\r\nfunction drawChart(temperature) {\r\n  const tempHours = getHoursCoords();\r\n  let i = 1;\r\n  function animation() {\r\n    if (i <= temperature.length) {\r\n      window.requestAnimationFrame(animation);\r\n    }\r\n    ctx.strokeStyle = "#FFE74A";\r\n    ctx.lineWidth = 3;\r\n    ctx.beginPath();\r\n    ctx.moveTo(blocks(tempHours[i-1]), 280 - blocks(temperature[i-1]));\r\n    ctx.arc(blocks(tempHours[i-1]), 280 - blocks(temperature[i-1]), 3, 0, Math.PI * 2, true);\r\n    ctx.lineTo(blocks(tempHours[i]), 280 - blocks(temperature[i]));\r\n    ctx.stroke();\r\n    i++;\r\n  }\r\n  animation();\r\n}\r\n\r\nasync function wait(ms) {\r\n  return new Promise(r => setTimeout(r, ms));\r\n}\r\n\r\nfunction getMousePosition(canvas, evt) {\r\n  let rect = canvas.getBoundingClientRect();\r\n  return {\r\n    x: evt.clientX - rect.left,\r\n    y: evt.clientY - rect.top\r\n  };\r\n}\r\n\r\nfunction filterTemperature(temperature) {\r\n  const temp = temperature\r\n    .map((obj) => obj.temp)\r\n    .filter((el, index) => index % 2 == 0);\r\n\r\n  return temp;\r\n}\r\n\r\nfunction temperatureToPixel(temp){\r\n  temp = temp.map(el => 280 - blocks(el));\r\n  return temp;\r\n}\r\n\r\nfunction hoursToPixel(hours) {\r\n  const hourrs = hours.map(el => blocks(el));\r\n  return hourrs;\r\n}\r\n\r\nfunction createTempObj(hour, temp, hourOfTemp, tempInHour){\r\n  const tempPointCoords = [];\r\n  for (let i = 0; i < temp.length; i++){\r\n    tempPointCoords.push({\r\n      x: hour[i],\r\n      y: temp[i],\r\n      xmin: hour[i] - 3,\r\n      xmax: hour[i] + 3,\r\n      ymin: temp[i] - 3,\r\n      ymax: temp[i] + 3,\r\n      hourTemp: {\r\n        hour: hourOfTemp[i],\r\n        temp: tempInHour[i]\r\n      },\r\n\r\n    })\r\n  }\r\n  return tempPointCoords;\r\n}\r\n\r\nfunction drawPoint(coords = {}, radius, color = \'white\') {\r\n  const mouseCoordinate = coords;\r\n  ctx.strokeStyle = color;\r\n  ctx.beginPath();\r\n  ctx.moveTo(mouseCoordinate.x, mouseCoordinate.y);\r\n  ctx.arc(mouseCoordinate.x, mouseCoordinate.y, radius, 0, Math.PI * 2, true);\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n  ctx.stroke();\r\n}\r\n\r\nlet condition = false;\r\nlet state = {};\r\nlet tooltip = document.getElementsByClassName("chartTemp__tooltip");\r\ntooltip = tooltip[0]\r\nfunction addPopUp(tempPoint) {\r\n  canvas.addEventListener(\'mousemove\', function(evt) {\r\n    const mouseCoords = getMousePosition(canvas, evt);\r\n    let boools = tempPoint.filter(el => {\r\n      const a = el.xmin <= mouseCoords.x;\r\n      const b = mouseCoords.x <= el.xmax;\r\n      const c = el.ymin <= mouseCoords.y;\r\n      const d = mouseCoords.y <= el.ymax;\r\n      return (a && b && c && d)})\r\n    \r\n    if(boools.length) {\r\n      drawPoint(boools[0], 1);\r\n      state = {...boools[0]};\r\n      condition = true;\r\n      tooltip.style.left = `${state.x + 5}px`;\r\n      tooltip.style.top = `${state.y - 35}px`;\r\n      tooltip.style.display = \'flex\';\r\n      tooltip.innerHTML = `Time: ${state.hourTemp.hour}:00, Temp: ${state.hourTemp.temp}Â°C`;\r\n    } \r\n    else if(!boools.length) {\r\n      drawPoint(state, 3, "#FFE74A");\r\n      condition = false;\r\n      state = {};\r\n      tooltip.style.display = \'none\';\r\n    } \r\n  })\r\n}\r\n\r\n\r\n\r\n\r\ngetLocation();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvbWFpbi5qcz85MjkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBcUQ7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVMsS0FBSyxZQUFZO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7O0FBRS9CO0FBQ0EsMkRBQTJELFNBQVMsT0FBTyxVQUFVLFNBQVMsT0FBTztBQUNyRztBQUNBLHlGQUF5RixTQUFTLE9BQU8sVUFBVTtBQUNuSCx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQSxtQ0FBbUMsb0JBQW9CLGFBQWEsb0JBQW9CO0FBQ3hGLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBLEdBQUc7QUFDSDs7Ozs7QUFLQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBzZXJ2aWNlIHdvcmtlciByZWdpc3RyYXRpb24gLSByZW1vdmUgaWYgeW91J3JlIG5vdCBnb2luZyB0byB1c2UgaXRcclxuXHJcbmlmIChcInNlcnZpY2VXb3JrZXJcIiBpbiBuYXZpZ2F0b3IpIHtcclxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgbmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIoXCJzZXJ2aWNld29ya2VyLmpzXCIpLnRoZW4oXHJcbiAgICAgIGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcclxuICAgICAgICAvLyBSZWdpc3RyYXRpb24gd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgIFwiU2VydmljZVdvcmtlciByZWdpc3RyYXRpb24gc3VjY2Vzc2Z1bCB3aXRoIHNjb3BlOiBcIixcclxuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5zY29wZVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAvLyByZWdpc3RyYXRpb24gZmFpbGVkIDooXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTZXJ2aWNlV29ya2VyIHJlZ2lzdHJhdGlvbiBmYWlsZWQ6IFwiLCBlcnIpO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH0pO1xyXG59XHJcblxyXG4vLyBwbGFjZSB5b3VyIGNvZGUgYmVsb3dcclxuY29uc3QgYXBpS2V5ID0gXCI1M2M1ZTk3Njc1YzhkM2Q4ZGEwN2U1NmFlYzVhM2EyMlwiO1xyXG5cclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGxhc3RUaW1lID0gMDtcclxuICB2YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKyt4KSB7XHJcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbeF0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICB9XHJcblxyXG4gIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xyXG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XHJcbiAgICAgIHZhciBpZCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHRpbWVUb0NhbGwpO1xyXG4gICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgICAgcmV0dXJuIGlkO1xyXG4gIH07XHJcblxyXG4gIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICB9O1xyXG59KCkpO1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBzdWNjZXNzKGxvYykge1xyXG4gIGNvbnN0IHsgY29vcmRzIH0gPSBsb2M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVycm9yKGVycikge1xyXG4gIGNvbnNvbGUud2FybihgRVJST1IoJHtlcnIuY29kZX0pOiAke2Vyci5tZXNzYWdlfWApO1xyXG59XHJcblxyXG5jb25zdCBvcHRpb25zID0ge1xyXG4gIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSxcclxuICB0aW1lb3V0OiA1MDAwLFxyXG4gIG1heGltdW1BZ2U6IDAsXHJcbn07XHJcblxyXG5mdW5jdGlvbiBjb25zb2xWYWx1ZSh2YWwpIHtcclxuICByZXR1cm4gdmFsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2NhdGlvbigpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cclxuICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24ocmVzb2x2ZSwgZXJyb3IpXHJcbiAgKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZ2V0TG9jYXRpb24oKSB7XHJcbiAgbGV0IHBvc2l0aW9uID0gYXdhaXQgbG9jYXRpb24oKTtcclxuICBwb3NpdGlvbiA9IGF3YWl0IHBvc2l0aW9uLmNvb3JkcztcclxuICBjb25zdCB7IGxhdGl0dWRlLCBsb25naXR1ZGUgfSA9IHBvc2l0aW9uO1xyXG5cclxuICBsZXQgd2VhdGhlckJ5UG9zaXRpb24gPSBhd2FpdCBmZXRjaChcclxuICAgIGBodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvd2VhdGhlcj9sYXQ9JHtsYXRpdHVkZX0mbG9uPSR7bG9uZ2l0dWRlfSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljJmxhbmc9cGxgXHJcbiAgKTtcclxuICBsZXQgd2VhdGhlckJ5SG91ciA9IGF3YWl0IGZldGNoKGBodHRwczovL2FwaS5vcGVud2VhdGhlcm1hcC5vcmcvZGF0YS8yLjUvb25lY2FsbD9sYXQ9JHtsYXRpdHVkZX0mbG9uPSR7bG9uZ2l0dWRlfSZcclxuICBleGNsdWRlPWhvdXJseSZhcHBpZD0ke2FwaUtleX0mdW5pdHM9bWV0cmljJmxhbmc9cGxgKTtcclxuICB3ZWF0aGVyQnlQb3NpdGlvbiA9IGF3YWl0IHdlYXRoZXJCeVBvc2l0aW9uLmpzb24oKTtcclxuICB3ZWF0aGVyQnlIb3VyID0gYXdhaXQgd2VhdGhlckJ5SG91ci5qc29uKCk7XHJcbiAgd2VhdGhlckJ5SG91ciA9IHdlYXRoZXJCeUhvdXIuaG91cmx5O1xyXG4gIGNvbnN0IGhvdXJPZldlYXRoZXIgPSBtYXBBbmRGaWx0ZXIod2VhdGhlckJ5SG91ci5tYXAoKG9iaikgPT4gb2JqLmR0KSk7XHJcbiAgbGV0IHRlbXBlcmF0dXJlID0gZmlsdGVyVGVtcGVyYXR1cmUod2VhdGhlckJ5SG91cik7XHJcbiAgY29uc3QgdGVtcGVyYXR1cmVDb29yZHMgPSB0ZW1wZXJhdHVyZVRvQ2hhcnRDb29yZHModGVtcGVyYXR1cmUpO1xyXG4gIFxyXG4gIGNvbnN0IHRlbXBQaXhlbHMgPSB0ZW1wZXJhdHVyZVRvUGl4ZWwodGVtcGVyYXR1cmVDb29yZHMpO1xyXG4gIGNvbnN0IGhvdXJzUGl4ZWxzID0gaG91cnNUb1BpeGVsKGdldEhvdXJzQ29vcmRzKCkpO1xyXG4gIFxyXG4gIGNvbnN0IHRlbXBQb2ludHMgPSBjcmVhdGVUZW1wT2JqKGhvdXJzUGl4ZWxzLCB0ZW1wUGl4ZWxzLCBob3VyT2ZXZWF0aGVyLCB0ZW1wZXJhdHVyZSk7XHJcblxyXG4gIFxyXG4gIFxyXG5cclxuICBcclxuICBcclxuICBncmlkKCk7XHJcbiAgZHJhd0F4aXMoaG91ck9mV2VhdGhlcik7XHJcbiAgYXdhaXQgd2FpdCg1MDApO1xyXG4gIGRyYXdDaGFydCh0ZW1wZXJhdHVyZUNvb3JkcylcclxuICBhZGRQb3BVcCh0ZW1wUG9pbnRzKTtcclxufVxyXG5cclxuXHJcblxyXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNoYXJ0VGVtcF9fY2FudmFzXCIpO1xyXG5jYW52YXMud2lkdGggPSA2NjA7XHJcbmNhbnZhcy5oZWlnaHQgPSAzMDk7XHJcbmNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG5mdW5jdGlvbiBncmlkKCkge1xyXG4gIGxldCBncmlkWCA9IDQwO1xyXG4gIGxldCBncmlkWSA9IDQwO1xyXG4gIGNvbnN0IGNlbGxTaXplID0gNDA7XHJcbiAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gIGN0eC5zdHJva2VTdHlsZSA9IFwibGlnaHRncmV5XCI7XHJcblxyXG4gIHdoaWxlIChncmlkWCA8PSBjYW52YXMud2lkdGggLSAyMCkge1xyXG4gICAgY3R4Lm1vdmVUbyhncmlkWCwgMjApO1xyXG4gICAgY3R4LmxpbmVUbyhncmlkWCwgY2FudmFzLmhlaWdodCAtIDIwKTtcclxuICAgIGdyaWRYICs9IGNlbGxTaXplO1xyXG4gIH1cclxuICB3aGlsZSAoZ3JpZFkgPD0gY2FudmFzLmhlaWdodCAtIDIwKSB7XHJcbiAgICBjdHgubW92ZVRvKDIwLCBncmlkWSk7XHJcbiAgICBjdHgubGluZVRvKGNhbnZhcy53aWR0aCAtIDEwLCBncmlkWSk7XHJcbiAgICBncmlkWSArPSBjZWxsU2l6ZTtcclxuICB9XHJcbiAgY3R4LnN0cm9rZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBibG9ja3MoY291bnQpIHtcclxuICByZXR1cm4gY291bnQgKiA0MDtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gZHJhd0F4aXMoaG91cnMpIHtcclxuICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgY3R4LnN0cm9rZVN0eWxlID0gXCJibGFja1wiO1xyXG4gIGN0eC5tb3ZlVG8oYmxvY2tzKDEpLCBibG9ja3MoMSAvIDIpKTtcclxuICBjdHgubGluZVRvKGJsb2NrcygxKSwgYmxvY2tzKDcpKTtcclxuICBjdHgubGluZVRvKGJsb2NrcygxNiksIGJsb2Nrcyg3KSk7XHJcblxyXG4gIGN0eC5tb3ZlVG8oYmxvY2tzKDEpLCBibG9ja3MoNykpO1xyXG4gIGxldCB0ZXh0ID0gMDtcclxuICBsZXQgdGV4dFkgPSBibG9ja3MoNyk7XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gNzsgaSsrKSB7XHJcbiAgICBjdHguc3Ryb2tlVGV4dCh0ZXh0LCBibG9ja3MoMSAvIDIpLCB0ZXh0WSk7XHJcbiAgICB0ZXh0WSAtPSA0MDtcclxuICAgIHRleHQgKz0gNTtcclxuICB9XHJcblxyXG4gIGN0eC5tb3ZlVG8oYmxvY2tzKDIpLCBibG9ja3MoNykpO1xyXG4gIGxldCB0ZXh0WCA9IGJsb2NrcygxLjkpO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8PSAxNTsgaSsrKSB7XHJcbiAgICBjdHguc3Ryb2tlVGV4dChob3Vyc1tpXSwgdGV4dFgsIGJsb2Nrcyg3LjUpKTtcclxuICAgIHRleHRYICs9IDQwO1xyXG4gIH1cclxuICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuZnVuY3Rpb24gdGltZXN0YW1wVG9UaW1lKHN0YW1wKSB7XHJcbiAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzdGFtcCAqIDEwMDApO1xyXG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1hcEFuZEZpbHRlcih0ZW1wQXJyYXkpIHtcclxuICB0ZW1wQXJyYXkgPSB0ZW1wQXJyYXkubWFwKChlbCkgPT4gdGltZXN0YW1wVG9UaW1lKGVsKSk7XHJcbiAgdGVtcEFycmF5ID0gdGVtcEFycmF5LmZpbHRlcigoZWwpID0+IGVsICUgMiA9PSAwKTtcclxuICByZXR1cm4gdGVtcEFycmF5O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0ZW1wZXJhdHVyZVRvQ2hhcnRDb29yZHModGVtcCl7XHJcbiAgbGV0IHRlbXBlcmF0dXJlID0gdGVtcC5tYXAoKGVsKSA9PiBlbCAvIDUpO1xyXG4gIHRlbXBlcmF0dXJlID0gdGVtcGVyYXR1cmUuc2xpY2UoMCwxNSk7XHJcbiAgcmV0dXJuIHRlbXBlcmF0dXJlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRIb3Vyc0Nvb3JkcygpIHtcclxuICBsZXQgaG91ck9mVGVtcCA9IFsuLi5BcnJheSgxNykua2V5cygpXVxyXG4gIGhvdXJPZlRlbXAgPSBob3VyT2ZUZW1wLnNsaWNlKDIsIDE3KTtcclxuXHJcbiAgcmV0dXJuIGhvdXJPZlRlbXA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRyYXdDaGFydCh0ZW1wZXJhdHVyZSkge1xyXG4gIGNvbnN0IHRlbXBIb3VycyA9IGdldEhvdXJzQ29vcmRzKCk7XHJcbiAgbGV0IGkgPSAxO1xyXG4gIGZ1bmN0aW9uIGFuaW1hdGlvbigpIHtcclxuICAgIGlmIChpIDw9IHRlbXBlcmF0dXJlLmxlbmd0aCkge1xyXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbik7XHJcbiAgICB9XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNGRkU3NEFcIjtcclxuICAgIGN0eC5saW5lV2lkdGggPSAzO1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4Lm1vdmVUbyhibG9ja3ModGVtcEhvdXJzW2ktMV0pLCAyODAgLSBibG9ja3ModGVtcGVyYXR1cmVbaS0xXSkpO1xyXG4gICAgY3R4LmFyYyhibG9ja3ModGVtcEhvdXJzW2ktMV0pLCAyODAgLSBibG9ja3ModGVtcGVyYXR1cmVbaS0xXSksIDMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICAgIGN0eC5saW5lVG8oYmxvY2tzKHRlbXBIb3Vyc1tpXSksIDI4MCAtIGJsb2Nrcyh0ZW1wZXJhdHVyZVtpXSkpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgaSsrO1xyXG4gIH1cclxuICBhbmltYXRpb24oKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gd2FpdChtcykge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgbXMpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0TW91c2VQb3NpdGlvbihjYW52YXMsIGV2dCkge1xyXG4gIGxldCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gIHJldHVybiB7XHJcbiAgICB4OiBldnQuY2xpZW50WCAtIHJlY3QubGVmdCxcclxuICAgIHk6IGV2dC5jbGllbnRZIC0gcmVjdC50b3BcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaWx0ZXJUZW1wZXJhdHVyZSh0ZW1wZXJhdHVyZSkge1xyXG4gIGNvbnN0IHRlbXAgPSB0ZW1wZXJhdHVyZVxyXG4gICAgLm1hcCgob2JqKSA9PiBvYmoudGVtcClcclxuICAgIC5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaW5kZXggJSAyID09IDApO1xyXG5cclxuICByZXR1cm4gdGVtcDtcclxufVxyXG5cclxuZnVuY3Rpb24gdGVtcGVyYXR1cmVUb1BpeGVsKHRlbXApe1xyXG4gIHRlbXAgPSB0ZW1wLm1hcChlbCA9PiAyODAgLSBibG9ja3MoZWwpKTtcclxuICByZXR1cm4gdGVtcDtcclxufVxyXG5cclxuZnVuY3Rpb24gaG91cnNUb1BpeGVsKGhvdXJzKSB7XHJcbiAgY29uc3QgaG91cnJzID0gaG91cnMubWFwKGVsID0+IGJsb2NrcyhlbCkpO1xyXG4gIHJldHVybiBob3VycnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRlbXBPYmooaG91ciwgdGVtcCwgaG91ck9mVGVtcCwgdGVtcEluSG91cil7XHJcbiAgY29uc3QgdGVtcFBvaW50Q29vcmRzID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKXtcclxuICAgIHRlbXBQb2ludENvb3Jkcy5wdXNoKHtcclxuICAgICAgeDogaG91cltpXSxcclxuICAgICAgeTogdGVtcFtpXSxcclxuICAgICAgeG1pbjogaG91cltpXSAtIDMsXHJcbiAgICAgIHhtYXg6IGhvdXJbaV0gKyAzLFxyXG4gICAgICB5bWluOiB0ZW1wW2ldIC0gMyxcclxuICAgICAgeW1heDogdGVtcFtpXSArIDMsXHJcbiAgICAgIGhvdXJUZW1wOiB7XHJcbiAgICAgICAgaG91cjogaG91ck9mVGVtcFtpXSxcclxuICAgICAgICB0ZW1wOiB0ZW1wSW5Ib3VyW2ldXHJcbiAgICAgIH0sXHJcblxyXG4gICAgfSlcclxuICB9XHJcbiAgcmV0dXJuIHRlbXBQb2ludENvb3JkcztcclxufVxyXG5cclxuZnVuY3Rpb24gZHJhd1BvaW50KGNvb3JkcyA9IHt9LCByYWRpdXMsIGNvbG9yID0gJ3doaXRlJykge1xyXG4gIGNvbnN0IG1vdXNlQ29vcmRpbmF0ZSA9IGNvb3JkcztcclxuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcclxuICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgY3R4Lm1vdmVUbyhtb3VzZUNvb3JkaW5hdGUueCwgbW91c2VDb29yZGluYXRlLnkpO1xyXG4gIGN0eC5hcmMobW91c2VDb29yZGluYXRlLngsIG1vdXNlQ29vcmRpbmF0ZS55LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuICBjdHguZmlsbFN0eWxlID0gY29sb3I7XHJcbiAgY3R4LmZpbGwoKTtcclxuICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuXHJcbmxldCBjb25kaXRpb24gPSBmYWxzZTtcclxubGV0IHN0YXRlID0ge307XHJcbmxldCB0b29sdGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImNoYXJ0VGVtcF9fdG9vbHRpcFwiKTtcclxudG9vbHRpcCA9IHRvb2x0aXBbMF1cclxuZnVuY3Rpb24gYWRkUG9wVXAodGVtcFBvaW50KSB7XHJcbiAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGV2dCkge1xyXG4gICAgY29uc3QgbW91c2VDb29yZHMgPSBnZXRNb3VzZVBvc2l0aW9uKGNhbnZhcywgZXZ0KTtcclxuICAgIGxldCBib29vbHMgPSB0ZW1wUG9pbnQuZmlsdGVyKGVsID0+IHtcclxuICAgICAgY29uc3QgYSA9IGVsLnhtaW4gPD0gbW91c2VDb29yZHMueDtcclxuICAgICAgY29uc3QgYiA9IG1vdXNlQ29vcmRzLnggPD0gZWwueG1heDtcclxuICAgICAgY29uc3QgYyA9IGVsLnltaW4gPD0gbW91c2VDb29yZHMueTtcclxuICAgICAgY29uc3QgZCA9IG1vdXNlQ29vcmRzLnkgPD0gZWwueW1heDtcclxuICAgICAgcmV0dXJuIChhICYmIGIgJiYgYyAmJiBkKX0pXHJcbiAgICBcclxuICAgIGlmKGJvb29scy5sZW5ndGgpIHtcclxuICAgICAgZHJhd1BvaW50KGJvb29sc1swXSwgMSk7XHJcbiAgICAgIHN0YXRlID0gey4uLmJvb29sc1swXX07XHJcbiAgICAgIGNvbmRpdGlvbiA9IHRydWU7XHJcbiAgICAgIHRvb2x0aXAuc3R5bGUubGVmdCA9IGAke3N0YXRlLnggKyA1fXB4YDtcclxuICAgICAgdG9vbHRpcC5zdHlsZS50b3AgPSBgJHtzdGF0ZS55IC0gMzV9cHhgO1xyXG4gICAgICB0b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgIHRvb2x0aXAuaW5uZXJIVE1MID0gYFRpbWU6ICR7c3RhdGUuaG91clRlbXAuaG91cn06MDAsIFRlbXA6ICR7c3RhdGUuaG91clRlbXAudGVtcH3CsENgO1xyXG4gICAgfSBcclxuICAgIGVsc2UgaWYoIWJvb29scy5sZW5ndGgpIHtcclxuICAgICAgZHJhd1BvaW50KHN0YXRlLCAzLCBcIiNGRkU3NEFcIik7XHJcbiAgICAgIGNvbmRpdGlvbiA9IGZhbHNlO1xyXG4gICAgICBzdGF0ZSA9IHt9O1xyXG4gICAgICB0b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9IFxyXG4gIH0pXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmdldExvY2F0aW9uKCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')}]);